SQL (Structured Query Language) - это язык программирования, который используется для
управления и работы с реляционными базами данных. Вот некоторые из основных возможностей
 работы с SQL:

1. **Создание базы данных**: SQL позволяет создавать новые базы данных с помощью команды
`CREATE DATABASE`.

2. **Создание таблицы**: SQL позволяет создавать новые таблицы в базе данных с помощью команды
`CREATE TABLE`.

3. **Вставка данных**: SQL позволяет вставлять данные в таблицу с помощью команды
`INSERT INTO`.

4. **Выборка данных**: SQL позволяет выбирать данные из таблицы с помощью команды
`SELECT`.

5. **Обновление данных**: SQL позволяет обновлять данные в таблице с помощью команды
`UPDATE`.

6. **Удаление данных**: SQL позволяет удалять данные из таблицы с помощью команды
 `DELETE`.

7. **Создание индексов**: SQL позволяет создавать индексы для ускорения поиска данных с помощью
команды `CREATE INDEX`.

8. **Создание представлений**: SQL позволяет создавать представления, которые являются
виртуальными таблицами, основанными на результатах запроса, с помощью команды `CREATE VIEW`.

9. **Создание хранимых процедур**: SQL позволяет создавать хранимые процедуры, которые
представляют собой набор SQL-команд, которые можно вызвать по имени, с помощью команды
`CREATE PROCEDURE`.

10. **Создание триггеров**: SQL позволяет создавать триггеры, которые автоматически
выполняются при определенных событиях, таких как вставка, обновление или удаление данных,
с помощью команды `CREATE TRIGGER`.

11. **Создание ограничений**: SQL позволяет создавать ограничения, такие как первичные ключи,
 внешние ключи, уникальные ограничения и ограничения проверки, с помощью команды `ALTER TABLE`.

12. **Создание транзакций**: SQL позволяет создавать транзакции, которые представляют
 собой набор SQL-команд, которые должны быть выполнены как единое целое, с помощью команды
 `BEGIN TRANSACTION`.

13. **Создание функций**: SQL позволяет создавать функции, которые могут быть использованы
 в запросах, с помощью команды `CREATE FUNCTION`.

14. **Создание последовательностей**: SQL позволяет создавать последовательности, которые
 генерируют уникальные числа, с помощью команды `CREATE SEQUENCE`.

15. **Создание схем**: SQL позволяет создавать схемы, которые представляют собой
 коллекцию объектов базы данных, с помощью команды `CREATE SCHEMA`.

16. **Создание ролей**: SQL позволяет создавать роли, которые представляют собой набор
привилегий, которые могут быть назначены пользователям, с помощью команды `CREATE ROLE`.

17. **Создание пользователей**: SQL позволяет создавать пользователей, которые могут быть
использованы для доступа к базе данных, с помощью команды `CREATE USER`.

18. **Создание синонимов**: SQL позволяет создавать синонимы, которые представляют собой
 альтернативные имена для объектов базы данных, с помощью команды `CREATE SYNONYM`.

19. **Создание типов данных**: SQL позволяет создавать пользовательские типы данных, с
помощью команды `CREATE TYPE`.

20. **Создание доменов**: SQL позволяет создавать домены, которые представляют собой
определение типа данных с ограничениями, с помощью команды `CREATE DOMAIN`.

21. **Создание каталогов**: SQL позволяет создавать каталоги, которые представляют
собой коллекцию объектов базы данных, с помощью команды `CREATE CATALOG`.

Работа с базами данных в Python обычно включает в себя широкое использование
 различные методов для выполнения операций с данными. Для начала давайте рассмотрим
 основные методы работы с базами данных, используя примеры на Python с библиотекой
 `sqlite3`, а также на примере `psycopg2` для PostgreSQL, так как они широко распространены.

### Основные операции с базами данных

1. **Создание базы данных и таблиц**
2. **Вставка данных**
3. **Запрос данных**
4. **Обновление данных**
5. **Удаление данных**
6. **Закрытие соединения**

### 1. Создание базы данных и таблиц

**SQLite:**

```python
import sqlite3

# Создание или подключение к базе данных
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Создание таблицы
cursor.execute('''
CREATE TABLE IF NOT EXISTS users (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    name TEXT NOT NULL,
    age INTEGER
)
''')

conn.commit()
conn.close()
```

**PostgreSQL:**

```python
import psycopg2

# Подключение к базе данных
conn = psycopg2.connect("dbname='example' user='youruser' password='yourpass'")
cursor = conn.cursor()

# Создание таблицы
cursor.execute('''
CREATE TABLE IF NOT EXISTS users (
    id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    age INTEGER
)
''')

conn.commit()
conn.close()
```

### 2. Вставка данных

**SQLite:**

```python
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Вставка данных
cursor.execute("INSERT INTO users (name, age) VALUES ('Alice', 30)")
cursor.execute("INSERT INTO users (name, age) VALUES ('Bob', 25)")

conn.commit()
conn.close()
```

**PostgreSQL:**

```python
conn = psycopg2.connect("dbname='example' user='youruser' password='yourpass'")
cursor = conn.cursor()

# Вставка данных
cursor.execute("INSERT INTO users (name, age) VALUES (%s, %s)", ('Alice', 30))
cursor.execute("INSERT INTO users (name, age) VALUES (%s, %s)", ('Bob', 25))

conn.commit()
conn.close()
```

### 3. Запрос данных

**SQLite:**

```python
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

cursor.execute("SELECT * FROM users")
rows = cursor.fetchall()
for row in rows:
    print(row)

conn.close()
```

**PostgreSQL:**

```python
conn = psycopg2.connect("dbname='example' user='youruser' password='yourpass'")
cursor = conn.cursor()

cursor.execute("SELECT * FROM users")
rows = cursor.fetchall()
for row in rows:
    print(row)

conn.close()
```

### 4. Обновление данных

**SQLite:**

```python
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Обновление данных
cursor.execute("UPDATE users SET age = ? WHERE name = ?", (31, 'Alice'))

conn.commit()
conn.close()
```

**PostgreSQL:**

```python
conn = psycopg2.connect("dbname='example' user='youruser' password='yourpass'")
cursor = conn.cursor()

# Обновление данных
cursor.execute("UPDATE users SET age = %s WHERE name = %s", (31, 'Alice'))

conn.commit()
conn.close()
```

### 5. Удаление данных

**SQLite:**

```python
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

# Удаление данных
cursor.execute("DELETE FROM users WHERE name = ?", ('Bob',))

conn.commit()
conn.close()
```

**PostgreSQL:**

```python
conn = psycopg2.connect("dbname='example' user='youruser' password='yourpass'")
cursor = conn.cursor()

# Удаление данных
cursor.execute("DELETE FROM users WHERE name = %s", ('Bob',))

conn.commit()
conn.close()
```

### 6. Закрытие соединения

Важно всегда закрывать соединение с базой данных после завершения операций.

```python
conn.close()  # Закрытие соединения
```

### Общие методы работы с курсором

- **`fetchone()`**: Извлечение одной строки из результата запроса.
- **`fetchall()`**: Извлечение всех строк из результата запроса.
- **`fetchmany(size)`**: Извлечение указанного количества строк из
результата запроса.

### Пример использования `fetchone()` и `fetchmany()`

**SQLite:**

```python
conn = sqlite3.connect('example.db')
cursor = conn.cursor()

cursor.execute("SELECT * FROM users")

# Извлечение одной строки
row = cursor.fetchone()
print(row)

# Извлечение нескольких строк
rows = cursor.fetchmany(2)
for row in rows:
    print(row)

conn.close()
```

**PostgreSQL:**

```python
conn = psycopg2.connect("dbname='example' user='youruser' password='yourpass'")
cursor = conn.cursor()

cursor.execute("SELECT * FROM users")

# Извлечение одной строки
row = cursor.fetchone()
print(row)

# Извлечение нескольких строк
rows = cursor.fetchmany(2)
for row in rows:
    print(row)

conn.close()
``
В SQL, оператор WHERE используется для фильтрации записей.
 Он позволяет нам указать условия, которые должны быть выполнены
 для того, чтобы запись была включена в результаты запроса.

Операторы сравнения, которые мы можем использовать в предложении
WHERE, включают:

- `=` (равно)
- `<>` или `!=` (не равно)
- `>` (больше)
- `<` (меньше)
- `>=` (больше или равно)
- `<=` (меньше или равно)
- `BETWEEN` (между двумя значениями)
- `LIKE` (похоже на шаблон)
- `IN` (в списке значений)

SELECT * FROM Студенты
WHERE Возраст > 20 AND Оценка > 80;

Оператор `LIMIT` и команда `ORDER BY` в SQL используются для управления
выборкой данных из базы данных. Давайте рассмотрим их подробнее.

### Оператор `ORDER BY`
Команда `ORDER BY` используется для сортировки результатов запроса по
одному или нескольким столбцам. Вы можете указать, по какому порядку вы
хотите выполнить сортировку — по возрастанию (`ASC`) или по убыванию (`DESC`).

**Синтаксис:**
```sql
SELECT column1, column2, ...
FROM table_name
ORDER BY column1 [ASC|DESC], column2 [ASC|DESC], ...;
```

**Пример:**
```sql
SELECT name, age
FROM users
ORDER BY age DESC;
```
Этот запрос выберет все имена и возраст из таблицы `users` и отсортирует
 результаты по возрасту от большего к меньшему.

### Оператор `LIMIT`
Оператор `LIMIT` позволяет ограничить количество строк, возвращаемых
запросом. Это особенно полезно, когда вы хотите получить только несколько
записей, например, для отображения на странице.

**Синтаксис:**
```sql
SELECT column1, column2, ...
FROM table_name
LIMIT number;
```

**Пример:**
```sql
SELECT name, age
FROM users
ORDER BY age DESC
LIMIT 5;
```
Этот запрос вернет только 5 пользователей с самым высоким возрастом из
таблицы
 `users`.

### Совместное использование `ORDER BY` и `LIMIT`
Часто `ORDER BY` и `LIMIT` используются вместе для того, чтобы получить,
 например, топ-N записей по какому-либо критерию.

**Пример:**
```sql
SELECT name, score
FROM games
ORDER BY score DESC
LIMIT 10;
```
Этот запрос вернет 10 пользователей с наивысшими оценками
из таблицы `games`.

Операторы `AND`, `OR` и `NOT` используются в SQL для создания сложных
логических условий в запросах. Они помогают объединить несколько условий
в операторе `WHERE` и управлять выборкой данных.

### Оператор `AND`
Оператор `AND` используется для объединения двух или более условий,
при этом все условия должны быть истинными для того, чтобы запись была
 включена в результат.

**Синтаксис:**
```sql
SELECT column1, column2
FROM table_name
WHERE condition1 AND condition2;
```

**Пример:**
```sql
SELECT name, age
FROM users
WHERE age > 18 AND city = 'Moscow';
```
Этот запрос выбирает имена и возраста пользователей, которые старше 18 лет
и проживают в Москве.

### Оператор `OR`
Оператор `OR` используется для объединения условий, при этом достаточно,
чтобы выполнялось хотя бы одно из условий, чтобы запись была включена в
результат.

**Синтаксис:**
```sql
SELECT column1, column2
FROM table_name
WHERE condition1 OR condition2;
```

**Пример:**
```sql
SELECT name, age
FROM users
WHERE city = 'Moscow' OR city = 'Saint Petersburg';
```
Этот запрос выбирает имена и возраста пользователей, которые проживают либо
 в Москве, либо в Санкт-Петербурге.

### Оператор `NOT`
Оператор `NOT` используется для отрицания условия. Если условие истинно,
то `NOT` делает его ложным и наоборот.

**Синтаксис:**
```sql
SELECT column1, column2
FROM table_name
WHERE NOT condition;
```

**Пример:**
```sql
SELECT name, age
FROM users
WHERE NOT city = 'Moscow';
```
Этот запрос выберет имена и возраста пользователей, которые не проживают
в Москве.

### Комбинирование операторов
Вы можете комбинировать эти операторы для создания более сложных условий.
Важно использовать скобки для уточнения порядка выполнения.

**Пример:**
```sql
SELECT name, age
FROM users
WHERE (age > 18 AND city = 'Moscow') OR (age < 18 AND city = 'Saint Petersburg');
```
Этот запрос выберет пользователей, которые либо старше 18 лет и проживают
в Москве, либо младше 18 лет и проживают в Санкт-Петербурге.

Изменение структуры таблиц и работа с индексами — важные аспекты управления
 базами данных, которые позволяют оптимизировать производительность и
  адаптировать схему данных под изменяющиеся требования. Давайте рассмотрим
  эти две темы подробнее.

## Изменение структуры таблиц

Изменение структуры таблицы в SQL осуществляется с помощью команды
`ALTER TABLE`. С ее помощью можно добавлять, изменять или удалять столбцы,
а также изменять другие характеристики таблицы.

### 1. Добавление столбцов
Чтобы добавить новый столбец в таблицу, используется команда `ADD COLUMN`.

**Синтаксис:**
```sql
ALTER TABLE table_name
ADD COLUMN new_column_name column_type;
```

**Пример:**
```sql
ALTER TABLE users
ADD COLUMN email VARCHAR(255);
```
Этот запрос добавит в таблицу `users` новый столбец `email` с типом
 данных `VARCHAR`.

### 2. Изменение столбцов
Для изменения типа данных существующего столбца или его свойств
(например, добавления ограничения `NOT NULL`) используется команда `MODIFY`.

**Синтаксис:**
```sql
ALTER TABLE table_name
MODIFY COLUMN column_name new_column_type;
```

**Пример:**
```sql
ALTER TABLE users
MODIFY COLUMN age INT NOT NULL;
```
Этот запрос изменит столбец `age`, сделав его обязательным для заполнения
(`NOT NULL`).

### 3. Удаление столбцов
Чтобы удалить столбец из таблицы, используется команда `DROP COLUMN`.

**Синтаксис:**
```sql
ALTER TABLE table_name
DROP COLUMN column_name;
```

**Пример:**
```sql
ALTER TABLE users
DROP COLUMN email;
```
Этот запрос удалит столбец `email` из таблицы `users`.

### 4. Переименование таблицы или столбца
Если необходимо изменить имя таблицы или одного из ее столбцов,
 это делается с помощью `RENAME`.

**Синтаксис для таблицы:**
```sql
ALTER TABLE old_table_name
RENAME TO new_table_name;
```

**Синтаксис для столбца:**
```sql
ALTER TABLE table_name
RENAME COLUMN old_column_name TO new_column_name;
```

**Пример:**
```sql
ALTER TABLE users
RENAME TO members;
```
Этот запрос переименует таблицу `users` в `members`.

## Индексы в базах данных

Индексы — это структуры данных, которые улучшают скорость операций
выборки данных в таблице за счет создания указателей на строки таблицы.

### 1. Создание индекса
Индексы могут быть созданы с помощью команды `CREATE INDEX`.

**Синтаксис:**
```sql
CREATE INDEX index_name
ON table_name (column1, column2, ...);
```

**Пример:**
```sql
CREATE INDEX idx_age ON users (age);
```
Этот запрос создаст индекс `idx_age` на столбце `age` таблицы `users`.

### 2. Удаление индекса
Чтобы удалить индекс, используется команда `DROP INDEX`.

**Синтаксис:**
```sql
DROP INDEX index_name;
```

**Пример:**
```sql
DROP INDEX idx_age;
```
Этот запрос удалит индекс `idx_age`.

### 3. Уникальные индексы
Вы можете создать уникальный индекс, чтобы гарантировать уникальность
значений в столбце или комбинации столбцов.

**Синтаксис:**
```sql
CREATE UNIQUE INDEX unique_index_name
ON table_name (column1);
```

**Пример:**
```sql
CREATE UNIQUE INDEX uq_email ON users (email);
```
Этот запрос создаст уникальный индекс на столбце `email` в таблице `users`.

### 4. Индексы и производительность
Использование индексов может значительно ускорить операции выборки,
но имеет некоторые нюансы:
- Индексы занимают дополнительное место на диске.
- При вставке, обновлении и удалении данных индексы требуют обновления,
  что может замедлить эти операции.

Первичные и внешние ключи являются важными концепциями в реляционных
базах данных, которые помогают гарантировать целостность данных и
устанавливать связи между таблицами. Давайте рассмотрим их более подробно.

## Первичный ключ (Primary Key)

Первичный ключ — это уникальный идентификатор для каждой записи в таблице.
Он обеспечивает уникальность строк и не допускает пустых значений (`NULL`).
Каждый набор полей, который определяется как первичный ключ, должен быть
уникальным для каждой строки в таблице.

### Основные характеристики первичного ключа:
- **Уникальность:** Значение первичного ключа всегда должно быть уникальным
по всему столбцу.
- **Не может содержать `NULL`:** Каждая запись должна иметь значение
первичного ключа.
- **Поддержка ссылочной целостности:** Первичный ключ может быть использован
 для создания ссылок в других таблицах.

### Пример создания первичного ключа:
Когда вы создаете таблицу, вы можете указать первичный ключ прямо
 при создании.

```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(255) UNIQUE
);
```

В этом примере `user_id` является первичным ключом таблицы `users`.

Если таблица уже существует, вы также можете добавить первичный ключ с
помощью команды `ALTER TABLE`:

```sql
ALTER TABLE users
ADD PRIMARY KEY (user_id);
```

## Внешний ключ (Foreign Key)

Внешний ключ — это колонка (или комбинация колонок) в одной таблице,
которая указывает на первичный ключ другой таблицы. Внешний ключ
обеспечивает связь между двумя таблицами и помогает поддерживать
 целостность данных.

### Основные характеристики внешнего ключа:
- **Ссылочная целостность:** Внешний ключ гарантирует, что значение
в столбце соответствует значению первичного ключа в связанной таблице.
- **Может содержать `NULL`:** Столбец внешнего ключа может принимать
значение `NULL`, если связь с записью в другой таблице не обязательна.

### Пример создания внешнего ключа:
Если у вас есть таблица заказов, которая ссылается на пользователей,
 вы можете создать внешний ключ, который указывает на первичный ключ
 таблицы пользователей.

```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT,
    order_date DATE,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

В этом примере внешний ключ `user_id` в таблице `orders` ссылается на
первичный ключ `user_id` в таблице `users`.

Если таблица уже существует, вы можете добавить внешний ключ следующим
образом:

```sql
ALTER TABLE orders
ADD CONSTRAINT fk_user
FOREIGN KEY (user_id) REFERENCES users(user_id);
```

### Обновление и удаление записей с внешними ключами
При обновлении и удалении записей в родительской таблице (таблице,
 на которую ссылается внешний ключ) могут возникнуть ограничения.
 Чтобы обеспечить целостность данных, можно использовать различные
  действия, такие как:
- **CASCADE:** Удалить записи из дочерней таблицы, если записи из
родительской таблицы удаляются.
- **SET NULL:** Установить значение `NULL` для внешнего ключа, если
 связанная запись удаляется.
- **NO ACTION/RESTRICT:** Запретить удаление или изменение записей
 в родительской таблице, если они все еще используются в дочерней таблице.

### Пример использования `CASCADE`:
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT,
    order_date DATE,
    FOREIGN KEY (user_id) REFERENCES users(user_id) ON DELETE CASCADE
);
```
С этим определением, если пользователь будет удален из таблицы `users`,
все заказы, связанные с этим пользователем в таблице `orders`, будут
автоматически удалены.

Ограничения целостности данных (или ограничения целостности) в
реляционных базах данных нужны для поддержания правильности и
надежности данных. Они обеспечивают определенные правила, которые
 данные должны соблюдать, таким образом, защищая систему от некорректной
 информации и ошибок. Давайте рассмотрим основные типы ограничений
  целостности данных.

## 1. Первичный ключ (Primary Key)

Первичный ключ — это ограничение, которое гарантирует уникальность
 каждой записи в таблице. Он определяет один или несколько столбцов,
 значения которых должны быть уникальными и не могут принимать `NULL`.

**Пример:**
```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    name VARCHAR(100),
    email VARCHAR(255) UNIQUE
);
```

## 2. Внешний ключ (Foreign Key)

Внешний ключ используется для обеспечения связи между записями
 в разных таблицах. Он указывает, что значения в одном столбце
  (или группе столбцов) должны соответствовать значениям первичного
   ключа в связанной таблице, что помогает поддерживать ссылочную целостность.

**Пример:**
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT,
    order_date DATE,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

## 3. Уникальность (Unique)

Ограничение уникальности гарантирует, что значения в указанном столбце
(или комбинации столбцов) будут уникальными для всех записей в таблице,
 но в отличие от первичного ключа, оно допускает наличие `NULL` значений.

**Пример:**
```sql
CREATE TABLE products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100),
    price DECIMAL(10, 2),
    UNIQUE (product_name)
);
```
В этом примере `product_name` должен быть уникальным для каждого продукта.

## 4. Ограничение `NOT NULL`

Ограничение `NOT NULL` гарантирует, что столбец не может содержать `NULL`
значения. Это полезно для обязательных полей, которые должны быть заполнены.

**Пример:**
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT NOT NULL,
    order_date DATE NOT NULL
);
```
В этом случае и `user_id`, и `order_date` должны содержать значения.

## 5. Ограничение `CHECK`

Ограничение `CHECK` используется для проверки значений на уровне строки.
Оно позволяет задать условие, которому должны соответствовать значения в
одном или нескольких столбцах.

**Пример:**
```sql
CREATE TABLE employees (
    employee_id INT PRIMARY KEY,
    salary DECIMAL(10, 2),
    CHECK (salary > 0)
);
```
Здесь ограничение гарантирует, что значение в столбце `salary` всегда
 будет больше 0.

## 6. Ограничение `DEFAULT`

Ограничение `DEFAULT` указывает значение, которое будет автоматически
присвоено столбцу, если вы не укажете значение при вставке новой записи.
Это удобно для установки стандартных значений.

**Пример:**
```sql
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    order_status VARCHAR(20) DEFAULT 'pending'
);
```
Если при создании нового заказа не указать статус, он будет автоматически
 установлен в `'pending'`.

Давайте рассмотрим каждый из указанных операторов и функций в SQL,
чтобы понять их назначение и увидеть примеры использования.

## 1. Оператор `IN`
Оператор `IN` позволяет выбирать записи, значения которых соответствуют
любому из определенных значений в списке.

**Синтаксис:**
```sql
SELECT column1, column2
FROM table_name
WHERE column1 IN (value1, value2, ...);
```

**Пример:**
```sql
SELECT name
FROM users
WHERE city IN ('Moscow', 'Saint Petersburg');
```
Этот запрос выборает пользователей, живущих в Москве или Санкт-Петербурге.

## 2. Оператор `LIKE`
Оператор `LIKE` используется для поиска записей по шаблону. Он часто
 применяется с подстановочными знаками (`%` для любого количества символов
  и `_` для одного символа).

**Синтаксис:**
```sql
SELECT column1, column2
FROM table_name
WHERE column1 LIKE 'pattern';
```

**Пример:**
```sql
SELECT name
FROM users
WHERE name LIKE 'A%';
```
Этот запрос найдет всех пользователей, чьи имена начинаются с буквы 'A'.

## 3. Оператор `BETWEEN`
Оператор `BETWEEN` используется для выборки данных в заданном диапазоне
 значений, включая границы.

**Синтаксис:**
```sql
SELECT column1, column2
FROM table_name
WHERE column1 BETWEEN value1 AND value2;
```

**Пример:**
```sql
SELECT name, age
FROM users
WHERE age BETWEEN 18 AND 30;
```
Этот запрос выбирает всех пользователей в возрасте от 18 до 30 лет
включительно.

## 4. Оператор `DISTINCT`
Оператор `DISTINCT` удаляет дублирующиеся записи из результатов выборки.

**Синтаксис:**
```sql
SELECT DISTINCT column1
FROM table_name;
```

**Пример:**
```sql
SELECT DISTINCT city
FROM users;
```
Этот запрос вернет уникальные значения городов, в которых живут пользователи.

## 5. Функция `COUNT`
Функция `COUNT` возвращает количество строк, соответствующих определенному
условию.

**Синтаксис:**
```sql
SELECT COUNT(column_name)
FROM table_name
WHERE condition;
```

**Пример:**
```sql
SELECT COUNT(*) AS total_users
FROM users;
```
Этот запрос вернет общее количество пользователей в таблице `users`.

## 6. Функция `SUM`
Функция `SUM` вычисляет сумму значений указанного столбца.

**Синтаксис:**
```sql
SELECT SUM(column_name)
FROM table_name
WHERE condition;
```

**Пример:**
```sql
SELECT SUM(price) AS total_sales
FROM orders;
```
Этот запрос вернет общую сумму цен заказов.

## 7. Функция `AVG`
Функция `AVG` вычисляет среднее значение для указанного столбца.

**Синтаксис:**
```sql
SELECT AVG(column_name)
FROM table_name
WHERE condition;
```

**Пример:**
```sql
SELECT AVG(salary) AS average_salary
FROM employees;
```
Этот запрос вернет среднюю зарплату сотрудников.

## 8. Функция `MIN` и `MAX`
Функции `MIN` и `MAX` возвращают минимальное и максимальное значения в
указанном столбце соответственно.

### Пример для `MIN`:
```sql
SELECT MIN(age) AS youngest_user
FROM users;
```
Этот запрос вернет возраст самого молодого пользователя.

### Пример для `MAX`:
```sql
SELECT MAX(age) AS oldest_user
FROM users;
```
Этот запрос вернет возраст самого старого пользователя.

## 9. `В SQL существует множество операторов и функций, которые помогают
 выполнять запросы к базе данных. Давайте рассмотрим некоторые из них,
  включая оператор `IN`, `LIKE`, `BETWEEN`, а также агрегатные функции и
  операторы для работы с группировкой и объединением данных.

## Операторы

### 1. Оператор `IN`
Оператор `IN` используется для проверки, находится ли значение в указанном
 списке значений.

**Синтаксис:**
```sql
SELECT column1, column2
FROM table_name
WHERE column_name IN (value1, value2, ...);
```

**Пример:**
```sql
SELECT name
FROM users
WHERE city IN ('Moscow', 'Saint Petersburg');
```
Этот запрос выберет имена пользователей, которые живут либо в Москве,
либо в Санкт-Петербурге.

### 2. Оператор `LIKE`
Оператор `LIKE` используется для поиска по шаблону в строковых данных.
Он поддерживает подстановочные знаки: `%` (любое количество символов) и `_`
(один любой символ).

**Синтаксис:**
```sql
SELECT column1, column2
FROM table_name
WHERE column_name LIKE 'pattern';
```

**Пример:**
```sql
SELECT name
FROM users
WHERE name LIKE 'A%';
```
Этот запрос выберет всех пользователей, чьи имена начинаются на букву `A`.

### 3. Оператор `BETWEEN`
Оператор `BETWEEN` позволяет отфильтровывать результаты по диапазону
значений. Включает границы диапазона.

**Синтаксис:**
```sql
SELECT column1, column2
FROM table_name
WHERE column_name BETWEEN value1 AND value2;
```

**Пример:**
```sql
SELECT name, age
FROM users
WHERE age BETWEEN 18 AND 25;
```
Этот запрос выберет пользователей в возрасте от 18 до 25 лет включительно.

## Агрегатные функции

### 4. `DISTINCT`
Опция `DISTINCT` используется для удаления дублирующихся записей из
результата запроса.

**Пример:**
```sql
SELECT DISTINCT city
FROM users;
```
Эти выбирает уникальные значения городов из таблицы `users`.

### 5. `COUNT()`
Функция `COUNT()` возвращает количество записей.

**Пример:**
```sql
SELECT COUNT(*) AS total_users
FROM users;
```
Этот запрос вернет общее количество пользователей в таблице.

### 6. `SUM()`
Функция `SUM()` возвращает сумму значений в числовом столбце.

**Пример:**
```sql
SELECT SUM(price) AS total_sales
FROM orders;
```
Этот запрос вернет общую сумму продаж из таблицы `orders`.

### 7. `AVG()`
Функция `AVG()` возвращает среднее значение в числовом столбце.

**Пример:**
```sql
SELECT AVG(age) AS average_age
FROM users;
```
Этот запрос вернет средний возраст пользователей.

### 8. `MIN()` и `MAX()`
Функции `MIN()` и `MAX()` возвращают минимальное и максимальное значение в
столбце соответственно.

**Примеры:**
```sql
SELECT MIN(age) AS youngest_user, MAX(age) AS oldest_user
FROM users;
```
Этот запрос вернет возраст самого младшего и самого старшего пользователя.

## Группировка данных

### 9. `GROUP BY`
Оператор `GROUP BY` используется для группировки строк,
которые имеют одинаковые значения в указанных столбцах.
Обычно используется вместе с агрегатными функциями.

**Пример:**
```sql
SELECT city, COUNT(*) AS user_count
FROM users
GROUP BY city;
```
Этот запрос вернет количество пользователей по городу.

### 10. `HAVING`
Оператор `HAVING` используется для фильтрации групп, создаваемых оператором
 `GROUP BY`. Он позволяет применять условия к агрегатным функциям.

**Пример:**
```sql
SELECT city, COUNT(*) AS user_count
FROM users
GROUP BY city
HAVING COUNT(*) > 10;
```
Этот запрос вернет только те города, в которых количество пользователей
больше 10.

## Объединение данных

### 11. `JOIN`
Оператор `JOIN` используется для объединения строк из двух или более таблиц,
 основываясь на связанных столбцах.

### 12. `INNER JOIN`
`INNER JOIN` возвращает только те записи, у которых есть совпадения в
обеих таблицах.

**Пример:**
```sql
SELECT users.name, orders.order_date
FROM users
INNER JOIN orders ON users.user_id = orders.user_id;
```
Этот запрос вернет имена пользователей и даты заказов только для
тех пользователей, которые сделали заказы.





